# syntax=docker/dockerfile:1

ARG PYTHON_VERSION=3.10.13
FROM python:${PYTHON_VERSION}-slim as base

# Prevents Python from writing pyc files.
ENV PYTHONDONTWRITEBYTECODE=1

# Keeps Python from buffering stdout and stderr to avoid situations where
# the application crashes without emitting any logs due to buffering.
ENV PYTHONUNBUFFERED=1

WORKDIR /app

# Download dependencies as a separate step to take advantage of Docker's caching.
# Leverage a cache mount to /root/.cache/pip to speed up subsequent builds.
# Leverage a bind mount to requirements.txt to avoid having to copy them into
# this layer.
RUN --mount=type=cache,target=/root/.cache/pip \
    --mount=type=bind,source=requirements.txt,target=requirements.txt \
    python -m pip install -r requirements.txt

# Install Node.js and npm
RUN apt-get update && \
    apt-get install -y curl && \
    curl -fsSL https://deb.nodesource.com/setup_20.x | bash - && \
    apt-get install -y nodejs && \
    npm install -g npm@latest && \
    apt-get clean && rm -rf /var/lib/apt/lists/*

# Switch to the non-privileged user to run the application.
# Copy the source code into the container.
COPY . .

# Change to the frontend directory and install dependencies and build the frontend
WORKDIR /app/frontend
RUN npm install && npm run build

# Change back to the app directory
WORKDIR /app

# Expose the port that the application listens on.
EXPOSE 5000

# Run the application.
CMD ["/bin/bash", "-c", "if [ \"$ENVIRONMENT\" = \"development\" ]; then \
        cd /app/frontend && nohup npm run watch > watch.log 2>&1 & cd /app && gunicorn 'app:app' --bind=0.0.0.0:5000 --reload; \
    else \
        cd /app/frontend && npm run build && cd /app && gunicorn 'app:app' --bind=0.0.0.0:5000 --timeout 180; \
    fi"]
